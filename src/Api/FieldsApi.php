<?php
/**
 * FieldsApi
 * PHP version 7.2
 *
 * @category Class
 * @package  Rossity\PhpQuickbase
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Quick Base API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.1-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Rossity\PhpQuickbase\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Rossity\PhpQuickbase\ApiException;
use Rossity\PhpQuickbase\Configuration;
use Rossity\PhpQuickbase\HeaderSelector;
use Rossity\PhpQuickbase\ObjectSerializer;

/**
 * FieldsApi Class Doc Comment
 *
 * @category Class
 * @package  Rossity\PhpQuickbase
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class FieldsApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex)
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createField
     *
     * Create a field
     *
     * @param  string $tableId The unique identifier of the table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     * @param  \Rossity\PhpQuickbase\Model\InlineObject8 $generated generated (optional)
     *
     * @throws \Rossity\PhpQuickbase\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return map[string,object]
     */
    public function createField($tableId, $qBRealmHostname, $authorization, $userAgent = null, $generated = null)
    {
        list($response) = $this->createFieldWithHttpInfo($tableId, $qBRealmHostname, $authorization, $userAgent, $generated);
        return $response;
    }

    /**
     * Operation createFieldWithHttpInfo
     *
     * Create a field
     *
     * @param  string $tableId The unique identifier of the table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     * @param  \Rossity\PhpQuickbase\Model\InlineObject8 $generated (optional)
     *
     * @throws \Rossity\PhpQuickbase\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of map[string,object], HTTP status code, HTTP response headers (array of strings)
     */
    public function createFieldWithHttpInfo($tableId, $qBRealmHostname, $authorization, $userAgent = null, $generated = null)
    {
        $request = $this->createFieldRequest($tableId, $qBRealmHostname, $authorization, $userAgent, $generated);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('map[string,object]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'map[string,object]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'map[string,object]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,object]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createFieldAsync
     *
     * Create a field
     *
     * @param  string $tableId The unique identifier of the table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     * @param  \Rossity\PhpQuickbase\Model\InlineObject8 $generated (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFieldAsync($tableId, $qBRealmHostname, $authorization, $userAgent = null, $generated = null)
    {
        return $this->createFieldAsyncWithHttpInfo($tableId, $qBRealmHostname, $authorization, $userAgent, $generated)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createFieldAsyncWithHttpInfo
     *
     * Create a field
     *
     * @param  string $tableId The unique identifier of the table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     * @param  \Rossity\PhpQuickbase\Model\InlineObject8 $generated (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createFieldAsyncWithHttpInfo($tableId, $qBRealmHostname, $authorization, $userAgent = null, $generated = null)
    {
        $returnType = 'map[string,object]';
        $request = $this->createFieldRequest($tableId, $qBRealmHostname, $authorization, $userAgent, $generated);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createField'
     *
     * @param  string $tableId The unique identifier of the table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     * @param  \Rossity\PhpQuickbase\Model\InlineObject8 $generated (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createFieldRequest($tableId, $qBRealmHostname, $authorization, $userAgent = null, $generated = null)
    {
        // verify the required parameter 'tableId' is set
        if ($tableId === null || (is_array($tableId) && count($tableId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tableId when calling createField'
            );
        }
        // verify the required parameter 'qBRealmHostname' is set
        if ($qBRealmHostname === null || (is_array($qBRealmHostname) && count($qBRealmHostname) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $qBRealmHostname when calling createField'
            );
        }
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling createField'
            );
        }

        $resourcePath = '/fields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($tableId)) {
            $tableId = ObjectSerializer::serializeCollection($tableId, '', true);
        }
        if ($tableId !== null) {
            $queryParams['tableId'] = $tableId;
        }

        // header params
        if ($qBRealmHostname !== null) {
            $headerParams['QB-Realm-Hostname'] = ObjectSerializer::toHeaderValue($qBRealmHostname);
        }
        // header params
        if ($userAgent !== null) {
            $headerParams['User-Agent'] = ObjectSerializer::toHeaderValue($userAgent);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }



        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($generated)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($generated));
            } else {
                $httpBody = $generated;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteFields
     *
     * Delete field(s)
     *
     * @param  string $tableId The unique identifier of the table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     * @param  \Rossity\PhpQuickbase\Model\InlineObject9 $generated generated (optional)
     *
     * @throws \Rossity\PhpQuickbase\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return map[string,object]
     */
    public function deleteFields($tableId, $qBRealmHostname, $authorization, $userAgent = null, $generated = null)
    {
        list($response) = $this->deleteFieldsWithHttpInfo($tableId, $qBRealmHostname, $authorization, $userAgent, $generated);
        return $response;
    }

    /**
     * Operation deleteFieldsWithHttpInfo
     *
     * Delete field(s)
     *
     * @param  string $tableId The unique identifier of the table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     * @param  \Rossity\PhpQuickbase\Model\InlineObject9 $generated (optional)
     *
     * @throws \Rossity\PhpQuickbase\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of map[string,object], HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFieldsWithHttpInfo($tableId, $qBRealmHostname, $authorization, $userAgent = null, $generated = null)
    {
        $request = $this->deleteFieldsRequest($tableId, $qBRealmHostname, $authorization, $userAgent, $generated);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('map[string,object]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'map[string,object]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'map[string,object]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,object]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteFieldsAsync
     *
     * Delete field(s)
     *
     * @param  string $tableId The unique identifier of the table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     * @param  \Rossity\PhpQuickbase\Model\InlineObject9 $generated (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFieldsAsync($tableId, $qBRealmHostname, $authorization, $userAgent = null, $generated = null)
    {
        return $this->deleteFieldsAsyncWithHttpInfo($tableId, $qBRealmHostname, $authorization, $userAgent, $generated)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFieldsAsyncWithHttpInfo
     *
     * Delete field(s)
     *
     * @param  string $tableId The unique identifier of the table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     * @param  \Rossity\PhpQuickbase\Model\InlineObject9 $generated (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFieldsAsyncWithHttpInfo($tableId, $qBRealmHostname, $authorization, $userAgent = null, $generated = null)
    {
        $returnType = 'map[string,object]';
        $request = $this->deleteFieldsRequest($tableId, $qBRealmHostname, $authorization, $userAgent, $generated);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteFields'
     *
     * @param  string $tableId The unique identifier of the table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     * @param  \Rossity\PhpQuickbase\Model\InlineObject9 $generated (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteFieldsRequest($tableId, $qBRealmHostname, $authorization, $userAgent = null, $generated = null)
    {
        // verify the required parameter 'tableId' is set
        if ($tableId === null || (is_array($tableId) && count($tableId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tableId when calling deleteFields'
            );
        }
        // verify the required parameter 'qBRealmHostname' is set
        if ($qBRealmHostname === null || (is_array($qBRealmHostname) && count($qBRealmHostname) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $qBRealmHostname when calling deleteFields'
            );
        }
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling deleteFields'
            );
        }

        $resourcePath = '/fields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($tableId)) {
            $tableId = ObjectSerializer::serializeCollection($tableId, '', true);
        }
        if ($tableId !== null) {
            $queryParams['tableId'] = $tableId;
        }

        // header params
        if ($qBRealmHostname !== null) {
            $headerParams['QB-Realm-Hostname'] = ObjectSerializer::toHeaderValue($qBRealmHostname);
        }
        // header params
        if ($userAgent !== null) {
            $headerParams['User-Agent'] = ObjectSerializer::toHeaderValue($userAgent);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }



        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($generated)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($generated));
            } else {
                $httpBody = $generated;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getField
     *
     * Get field
     *
     * @param  int $fieldId The unique identifier (fid) of the field. (required)
     * @param  string $tableId The unique identifier (dbid) of the table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  bool $includeFieldPerms Set to &#39;true&#39; if you&#39;d like to get back the custom permissions for the field(s). (optional, default to false)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \Rossity\PhpQuickbase\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return map[string,object]
     */
    public function getField($fieldId, $tableId, $qBRealmHostname, $authorization, $includeFieldPerms = false, $userAgent = null)
    {
        list($response) = $this->getFieldWithHttpInfo($fieldId, $tableId, $qBRealmHostname, $authorization, $includeFieldPerms, $userAgent);
        return $response;
    }

    /**
     * Operation getFieldWithHttpInfo
     *
     * Get field
     *
     * @param  int $fieldId The unique identifier (fid) of the field. (required)
     * @param  string $tableId The unique identifier (dbid) of the table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  bool $includeFieldPerms Set to &#39;true&#39; if you&#39;d like to get back the custom permissions for the field(s). (optional, default to false)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \Rossity\PhpQuickbase\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of map[string,object], HTTP status code, HTTP response headers (array of strings)
     */
    public function getFieldWithHttpInfo($fieldId, $tableId, $qBRealmHostname, $authorization, $includeFieldPerms = false, $userAgent = null)
    {
        $request = $this->getFieldRequest($fieldId, $tableId, $qBRealmHostname, $authorization, $includeFieldPerms, $userAgent);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('map[string,object]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'map[string,object]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'map[string,object]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,object]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFieldAsync
     *
     * Get field
     *
     * @param  int $fieldId The unique identifier (fid) of the field. (required)
     * @param  string $tableId The unique identifier (dbid) of the table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  bool $includeFieldPerms Set to &#39;true&#39; if you&#39;d like to get back the custom permissions for the field(s). (optional, default to false)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFieldAsync($fieldId, $tableId, $qBRealmHostname, $authorization, $includeFieldPerms = false, $userAgent = null)
    {
        return $this->getFieldAsyncWithHttpInfo($fieldId, $tableId, $qBRealmHostname, $authorization, $includeFieldPerms, $userAgent)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFieldAsyncWithHttpInfo
     *
     * Get field
     *
     * @param  int $fieldId The unique identifier (fid) of the field. (required)
     * @param  string $tableId The unique identifier (dbid) of the table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  bool $includeFieldPerms Set to &#39;true&#39; if you&#39;d like to get back the custom permissions for the field(s). (optional, default to false)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFieldAsyncWithHttpInfo($fieldId, $tableId, $qBRealmHostname, $authorization, $includeFieldPerms = false, $userAgent = null)
    {
        $returnType = 'map[string,object]';
        $request = $this->getFieldRequest($fieldId, $tableId, $qBRealmHostname, $authorization, $includeFieldPerms, $userAgent);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getField'
     *
     * @param  int $fieldId The unique identifier (fid) of the field. (required)
     * @param  string $tableId The unique identifier (dbid) of the table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  bool $includeFieldPerms Set to &#39;true&#39; if you&#39;d like to get back the custom permissions for the field(s). (optional, default to false)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getFieldRequest($fieldId, $tableId, $qBRealmHostname, $authorization, $includeFieldPerms = false, $userAgent = null)
    {
        // verify the required parameter 'fieldId' is set
        if ($fieldId === null || (is_array($fieldId) && count($fieldId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fieldId when calling getField'
            );
        }
        // verify the required parameter 'tableId' is set
        if ($tableId === null || (is_array($tableId) && count($tableId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tableId when calling getField'
            );
        }
        // verify the required parameter 'qBRealmHostname' is set
        if ($qBRealmHostname === null || (is_array($qBRealmHostname) && count($qBRealmHostname) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $qBRealmHostname when calling getField'
            );
        }
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling getField'
            );
        }

        $resourcePath = '/fields/{fieldId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($tableId)) {
            $tableId = ObjectSerializer::serializeCollection($tableId, '', true);
        }
        if ($tableId !== null) {
            $queryParams['tableId'] = $tableId;
        }
        // query params
        if (is_array($includeFieldPerms)) {
            $includeFieldPerms = ObjectSerializer::serializeCollection($includeFieldPerms, '', true);
        }
        if ($includeFieldPerms !== null) {
            $queryParams['includeFieldPerms'] = $includeFieldPerms;
        }

        // header params
        if ($qBRealmHostname !== null) {
            $headerParams['QB-Realm-Hostname'] = ObjectSerializer::toHeaderValue($qBRealmHostname);
        }
        // header params
        if ($userAgent !== null) {
            $headerParams['User-Agent'] = ObjectSerializer::toHeaderValue($userAgent);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($fieldId !== null) {
            $resourcePath = str_replace(
                '{' . 'fieldId' . '}',
                ObjectSerializer::toPathValue($fieldId),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFieldUsage
     *
     * Get usage for a field
     *
     * @param  int $fieldId The unique identifier (fid) of the field. (required)
     * @param  string $tableId The unique identifier (dbid) of the table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \Rossity\PhpQuickbase\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Rossity\PhpQuickbase\Model\InlineResponse2004[]
     */
    public function getFieldUsage($fieldId, $tableId, $qBRealmHostname, $authorization, $userAgent = null)
    {
        list($response) = $this->getFieldUsageWithHttpInfo($fieldId, $tableId, $qBRealmHostname, $authorization, $userAgent);
        return $response;
    }

    /**
     * Operation getFieldUsageWithHttpInfo
     *
     * Get usage for a field
     *
     * @param  int $fieldId The unique identifier (fid) of the field. (required)
     * @param  string $tableId The unique identifier (dbid) of the table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \Rossity\PhpQuickbase\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Rossity\PhpQuickbase\Model\InlineResponse2004[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getFieldUsageWithHttpInfo($fieldId, $tableId, $qBRealmHostname, $authorization, $userAgent = null)
    {
        $request = $this->getFieldUsageRequest($fieldId, $tableId, $qBRealmHostname, $authorization, $userAgent);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Rossity\PhpQuickbase\Model\InlineResponse2004[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rossity\PhpQuickbase\Model\InlineResponse2004[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Rossity\PhpQuickbase\Model\InlineResponse2004[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rossity\PhpQuickbase\Model\InlineResponse2004[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFieldUsageAsync
     *
     * Get usage for a field
     *
     * @param  int $fieldId The unique identifier (fid) of the field. (required)
     * @param  string $tableId The unique identifier (dbid) of the table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFieldUsageAsync($fieldId, $tableId, $qBRealmHostname, $authorization, $userAgent = null)
    {
        return $this->getFieldUsageAsyncWithHttpInfo($fieldId, $tableId, $qBRealmHostname, $authorization, $userAgent)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFieldUsageAsyncWithHttpInfo
     *
     * Get usage for a field
     *
     * @param  int $fieldId The unique identifier (fid) of the field. (required)
     * @param  string $tableId The unique identifier (dbid) of the table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFieldUsageAsyncWithHttpInfo($fieldId, $tableId, $qBRealmHostname, $authorization, $userAgent = null)
    {
        $returnType = '\Rossity\PhpQuickbase\Model\InlineResponse2004[]';
        $request = $this->getFieldUsageRequest($fieldId, $tableId, $qBRealmHostname, $authorization, $userAgent);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFieldUsage'
     *
     * @param  int $fieldId The unique identifier (fid) of the field. (required)
     * @param  string $tableId The unique identifier (dbid) of the table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getFieldUsageRequest($fieldId, $tableId, $qBRealmHostname, $authorization, $userAgent = null)
    {
        // verify the required parameter 'fieldId' is set
        if ($fieldId === null || (is_array($fieldId) && count($fieldId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fieldId when calling getFieldUsage'
            );
        }
        // verify the required parameter 'tableId' is set
        if ($tableId === null || (is_array($tableId) && count($tableId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tableId when calling getFieldUsage'
            );
        }
        // verify the required parameter 'qBRealmHostname' is set
        if ($qBRealmHostname === null || (is_array($qBRealmHostname) && count($qBRealmHostname) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $qBRealmHostname when calling getFieldUsage'
            );
        }
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling getFieldUsage'
            );
        }

        $resourcePath = '/fields/usage/{fieldId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($tableId)) {
            $tableId = ObjectSerializer::serializeCollection($tableId, '', true);
        }
        if ($tableId !== null) {
            $queryParams['tableId'] = $tableId;
        }

        // header params
        if ($qBRealmHostname !== null) {
            $headerParams['QB-Realm-Hostname'] = ObjectSerializer::toHeaderValue($qBRealmHostname);
        }
        // header params
        if ($userAgent !== null) {
            $headerParams['User-Agent'] = ObjectSerializer::toHeaderValue($userAgent);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($fieldId !== null) {
            $resourcePath = str_replace(
                '{' . 'fieldId' . '}',
                ObjectSerializer::toPathValue($fieldId),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFields
     *
     * Get fields for a table
     *
     * @param  string $tableId The unique identifier (dbid) of the table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  bool $includeFieldPerms Set to &#39;true&#39; if you&#39;d like to get back the custom permissions for the field(s). (optional, default to false)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \Rossity\PhpQuickbase\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Rossity\PhpQuickbase\Model\InlineResponse2003[]
     */
    public function getFields($tableId, $qBRealmHostname, $authorization, $includeFieldPerms = false, $userAgent = null)
    {
        list($response) = $this->getFieldsWithHttpInfo($tableId, $qBRealmHostname, $authorization, $includeFieldPerms, $userAgent);
        return $response;
    }

    /**
     * Operation getFieldsWithHttpInfo
     *
     * Get fields for a table
     *
     * @param  string $tableId The unique identifier (dbid) of the table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  bool $includeFieldPerms Set to &#39;true&#39; if you&#39;d like to get back the custom permissions for the field(s). (optional, default to false)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \Rossity\PhpQuickbase\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Rossity\PhpQuickbase\Model\InlineResponse2003[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getFieldsWithHttpInfo($tableId, $qBRealmHostname, $authorization, $includeFieldPerms = false, $userAgent = null)
    {
        $request = $this->getFieldsRequest($tableId, $qBRealmHostname, $authorization, $includeFieldPerms, $userAgent);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Rossity\PhpQuickbase\Model\InlineResponse2003[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rossity\PhpQuickbase\Model\InlineResponse2003[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Rossity\PhpQuickbase\Model\InlineResponse2003[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rossity\PhpQuickbase\Model\InlineResponse2003[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFieldsAsync
     *
     * Get fields for a table
     *
     * @param  string $tableId The unique identifier (dbid) of the table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  bool $includeFieldPerms Set to &#39;true&#39; if you&#39;d like to get back the custom permissions for the field(s). (optional, default to false)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFieldsAsync($tableId, $qBRealmHostname, $authorization, $includeFieldPerms = false, $userAgent = null)
    {
        return $this->getFieldsAsyncWithHttpInfo($tableId, $qBRealmHostname, $authorization, $includeFieldPerms, $userAgent)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFieldsAsyncWithHttpInfo
     *
     * Get fields for a table
     *
     * @param  string $tableId The unique identifier (dbid) of the table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  bool $includeFieldPerms Set to &#39;true&#39; if you&#39;d like to get back the custom permissions for the field(s). (optional, default to false)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFieldsAsyncWithHttpInfo($tableId, $qBRealmHostname, $authorization, $includeFieldPerms = false, $userAgent = null)
    {
        $returnType = '\Rossity\PhpQuickbase\Model\InlineResponse2003[]';
        $request = $this->getFieldsRequest($tableId, $qBRealmHostname, $authorization, $includeFieldPerms, $userAgent);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFields'
     *
     * @param  string $tableId The unique identifier (dbid) of the table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  bool $includeFieldPerms Set to &#39;true&#39; if you&#39;d like to get back the custom permissions for the field(s). (optional, default to false)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getFieldsRequest($tableId, $qBRealmHostname, $authorization, $includeFieldPerms = false, $userAgent = null)
    {
        // verify the required parameter 'tableId' is set
        if ($tableId === null || (is_array($tableId) && count($tableId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tableId when calling getFields'
            );
        }
        // verify the required parameter 'qBRealmHostname' is set
        if ($qBRealmHostname === null || (is_array($qBRealmHostname) && count($qBRealmHostname) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $qBRealmHostname when calling getFields'
            );
        }
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling getFields'
            );
        }

        $resourcePath = '/fields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($tableId)) {
            $tableId = ObjectSerializer::serializeCollection($tableId, '', true);
        }
        if ($tableId !== null) {
            $queryParams['tableId'] = $tableId;
        }
        // query params
        if (is_array($includeFieldPerms)) {
            $includeFieldPerms = ObjectSerializer::serializeCollection($includeFieldPerms, '', true);
        }
        if ($includeFieldPerms !== null) {
            $queryParams['includeFieldPerms'] = $includeFieldPerms;
        }

        // header params
        if ($qBRealmHostname !== null) {
            $headerParams['QB-Realm-Hostname'] = ObjectSerializer::toHeaderValue($qBRealmHostname);
        }
        // header params
        if ($userAgent !== null) {
            $headerParams['User-Agent'] = ObjectSerializer::toHeaderValue($userAgent);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }



        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getFieldsUsage
     *
     * Get usage for all fields
     *
     * @param  string $tableId The unique identifier (dbid) of the table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  int $skip The number of fields to skip from the list. (optional)
     * @param  int $top The maximum number of fields to return. (optional)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \Rossity\PhpQuickbase\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Rossity\PhpQuickbase\Model\InlineResponse2004[]
     */
    public function getFieldsUsage($tableId, $qBRealmHostname, $authorization, $skip = null, $top = null, $userAgent = null)
    {
        list($response) = $this->getFieldsUsageWithHttpInfo($tableId, $qBRealmHostname, $authorization, $skip, $top, $userAgent);
        return $response;
    }

    /**
     * Operation getFieldsUsageWithHttpInfo
     *
     * Get usage for all fields
     *
     * @param  string $tableId The unique identifier (dbid) of the table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  int $skip The number of fields to skip from the list. (optional)
     * @param  int $top The maximum number of fields to return. (optional)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \Rossity\PhpQuickbase\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Rossity\PhpQuickbase\Model\InlineResponse2004[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getFieldsUsageWithHttpInfo($tableId, $qBRealmHostname, $authorization, $skip = null, $top = null, $userAgent = null)
    {
        $request = $this->getFieldsUsageRequest($tableId, $qBRealmHostname, $authorization, $skip, $top, $userAgent);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Rossity\PhpQuickbase\Model\InlineResponse2004[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rossity\PhpQuickbase\Model\InlineResponse2004[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Rossity\PhpQuickbase\Model\InlineResponse2004[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rossity\PhpQuickbase\Model\InlineResponse2004[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getFieldsUsageAsync
     *
     * Get usage for all fields
     *
     * @param  string $tableId The unique identifier (dbid) of the table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  int $skip The number of fields to skip from the list. (optional)
     * @param  int $top The maximum number of fields to return. (optional)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFieldsUsageAsync($tableId, $qBRealmHostname, $authorization, $skip = null, $top = null, $userAgent = null)
    {
        return $this->getFieldsUsageAsyncWithHttpInfo($tableId, $qBRealmHostname, $authorization, $skip, $top, $userAgent)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getFieldsUsageAsyncWithHttpInfo
     *
     * Get usage for all fields
     *
     * @param  string $tableId The unique identifier (dbid) of the table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  int $skip The number of fields to skip from the list. (optional)
     * @param  int $top The maximum number of fields to return. (optional)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getFieldsUsageAsyncWithHttpInfo($tableId, $qBRealmHostname, $authorization, $skip = null, $top = null, $userAgent = null)
    {
        $returnType = '\Rossity\PhpQuickbase\Model\InlineResponse2004[]';
        $request = $this->getFieldsUsageRequest($tableId, $qBRealmHostname, $authorization, $skip, $top, $userAgent);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getFieldsUsage'
     *
     * @param  string $tableId The unique identifier (dbid) of the table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  int $skip The number of fields to skip from the list. (optional)
     * @param  int $top The maximum number of fields to return. (optional)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getFieldsUsageRequest($tableId, $qBRealmHostname, $authorization, $skip = null, $top = null, $userAgent = null)
    {
        // verify the required parameter 'tableId' is set
        if ($tableId === null || (is_array($tableId) && count($tableId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tableId when calling getFieldsUsage'
            );
        }
        // verify the required parameter 'qBRealmHostname' is set
        if ($qBRealmHostname === null || (is_array($qBRealmHostname) && count($qBRealmHostname) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $qBRealmHostname when calling getFieldsUsage'
            );
        }
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling getFieldsUsage'
            );
        }

        $resourcePath = '/fields/usage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($tableId)) {
            $tableId = ObjectSerializer::serializeCollection($tableId, '', true);
        }
        if ($tableId !== null) {
            $queryParams['tableId'] = $tableId;
        }
        // query params
        if (is_array($skip)) {
            $skip = ObjectSerializer::serializeCollection($skip, '', true);
        }
        if ($skip !== null) {
            $queryParams['skip'] = $skip;
        }
        // query params
        if (is_array($top)) {
            $top = ObjectSerializer::serializeCollection($top, '', true);
        }
        if ($top !== null) {
            $queryParams['top'] = $top;
        }

        // header params
        if ($qBRealmHostname !== null) {
            $headerParams['QB-Realm-Hostname'] = ObjectSerializer::toHeaderValue($qBRealmHostname);
        }
        // header params
        if ($userAgent !== null) {
            $headerParams['User-Agent'] = ObjectSerializer::toHeaderValue($userAgent);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }



        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateField
     *
     * Update a field
     *
     * @param  int $fieldId The unique identifier (fid) of the field. (required)
     * @param  string $tableId The unique identifier of the table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     * @param  \Rossity\PhpQuickbase\Model\InlineObject10 $generated generated (optional)
     *
     * @throws \Rossity\PhpQuickbase\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return map[string,object]
     */
    public function updateField($fieldId, $tableId, $qBRealmHostname, $authorization, $userAgent = null, $generated = null)
    {
        list($response) = $this->updateFieldWithHttpInfo($fieldId, $tableId, $qBRealmHostname, $authorization, $userAgent, $generated);
        return $response;
    }

    /**
     * Operation updateFieldWithHttpInfo
     *
     * Update a field
     *
     * @param  int $fieldId The unique identifier (fid) of the field. (required)
     * @param  string $tableId The unique identifier of the table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     * @param  \Rossity\PhpQuickbase\Model\InlineObject10 $generated (optional)
     *
     * @throws \Rossity\PhpQuickbase\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of map[string,object], HTTP status code, HTTP response headers (array of strings)
     */
    public function updateFieldWithHttpInfo($fieldId, $tableId, $qBRealmHostname, $authorization, $userAgent = null, $generated = null)
    {
        $request = $this->updateFieldRequest($fieldId, $tableId, $qBRealmHostname, $authorization, $userAgent, $generated);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('map[string,object]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'map[string,object]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'map[string,object]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,object]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateFieldAsync
     *
     * Update a field
     *
     * @param  int $fieldId The unique identifier (fid) of the field. (required)
     * @param  string $tableId The unique identifier of the table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     * @param  \Rossity\PhpQuickbase\Model\InlineObject10 $generated (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateFieldAsync($fieldId, $tableId, $qBRealmHostname, $authorization, $userAgent = null, $generated = null)
    {
        return $this->updateFieldAsyncWithHttpInfo($fieldId, $tableId, $qBRealmHostname, $authorization, $userAgent, $generated)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateFieldAsyncWithHttpInfo
     *
     * Update a field
     *
     * @param  int $fieldId The unique identifier (fid) of the field. (required)
     * @param  string $tableId The unique identifier of the table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     * @param  \Rossity\PhpQuickbase\Model\InlineObject10 $generated (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateFieldAsyncWithHttpInfo($fieldId, $tableId, $qBRealmHostname, $authorization, $userAgent = null, $generated = null)
    {
        $returnType = 'map[string,object]';
        $request = $this->updateFieldRequest($fieldId, $tableId, $qBRealmHostname, $authorization, $userAgent, $generated);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateField'
     *
     * @param  int $fieldId The unique identifier (fid) of the field. (required)
     * @param  string $tableId The unique identifier of the table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     * @param  \Rossity\PhpQuickbase\Model\InlineObject10 $generated (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateFieldRequest($fieldId, $tableId, $qBRealmHostname, $authorization, $userAgent = null, $generated = null)
    {
        // verify the required parameter 'fieldId' is set
        if ($fieldId === null || (is_array($fieldId) && count($fieldId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $fieldId when calling updateField'
            );
        }
        // verify the required parameter 'tableId' is set
        if ($tableId === null || (is_array($tableId) && count($tableId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tableId when calling updateField'
            );
        }
        // verify the required parameter 'qBRealmHostname' is set
        if ($qBRealmHostname === null || (is_array($qBRealmHostname) && count($qBRealmHostname) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $qBRealmHostname when calling updateField'
            );
        }
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling updateField'
            );
        }

        $resourcePath = '/fields/{fieldId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($tableId)) {
            $tableId = ObjectSerializer::serializeCollection($tableId, '', true);
        }
        if ($tableId !== null) {
            $queryParams['tableId'] = $tableId;
        }

        // header params
        if ($qBRealmHostname !== null) {
            $headerParams['QB-Realm-Hostname'] = ObjectSerializer::toHeaderValue($qBRealmHostname);
        }
        // header params
        if ($userAgent !== null) {
            $headerParams['User-Agent'] = ObjectSerializer::toHeaderValue($userAgent);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($fieldId !== null) {
            $resourcePath = str_replace(
                '{' . 'fieldId' . '}',
                ObjectSerializer::toPathValue($fieldId),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($generated)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($generated));
            } else {
                $httpBody = $generated;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
