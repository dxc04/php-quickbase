<?php
/**
 * TablesApi
 * PHP version 7.2
 *
 * @category Class
 * @package  Rossity\PhpQuickbase
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Quick Base API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 5.0.1-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Rossity\PhpQuickbase\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Rossity\PhpQuickbase\ApiException;
use Rossity\PhpQuickbase\Configuration;
use Rossity\PhpQuickbase\HeaderSelector;
use Rossity\PhpQuickbase\ObjectSerializer;

/**
 * TablesApi Class Doc Comment
 *
 * @category Class
 * @package  Rossity\PhpQuickbase
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class TablesApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex)
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createRelationship
     *
     * Create a relationship
     *
     * @param  string $tableId The unique identifier (dbid) of the table. This will be the child table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     * @param  \Rossity\PhpQuickbase\Model\InlineObject6 $generated generated (optional)
     *
     * @throws \Rossity\PhpQuickbase\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return map[string,object]
     */
    public function createRelationship($tableId, $qBRealmHostname, $authorization, $userAgent = null, $generated = null)
    {
        list($response) = $this->createRelationshipWithHttpInfo($tableId, $qBRealmHostname, $authorization, $userAgent, $generated);
        return $response;
    }

    /**
     * Operation createRelationshipWithHttpInfo
     *
     * Create a relationship
     *
     * @param  string $tableId The unique identifier (dbid) of the table. This will be the child table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     * @param  \Rossity\PhpQuickbase\Model\InlineObject6 $generated (optional)
     *
     * @throws \Rossity\PhpQuickbase\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of map[string,object], HTTP status code, HTTP response headers (array of strings)
     */
    public function createRelationshipWithHttpInfo($tableId, $qBRealmHostname, $authorization, $userAgent = null, $generated = null)
    {
        $request = $this->createRelationshipRequest($tableId, $qBRealmHostname, $authorization, $userAgent, $generated);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('map[string,object]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'map[string,object]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'map[string,object]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,object]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createRelationshipAsync
     *
     * Create a relationship
     *
     * @param  string $tableId The unique identifier (dbid) of the table. This will be the child table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     * @param  \Rossity\PhpQuickbase\Model\InlineObject6 $generated (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRelationshipAsync($tableId, $qBRealmHostname, $authorization, $userAgent = null, $generated = null)
    {
        return $this->createRelationshipAsyncWithHttpInfo($tableId, $qBRealmHostname, $authorization, $userAgent, $generated)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createRelationshipAsyncWithHttpInfo
     *
     * Create a relationship
     *
     * @param  string $tableId The unique identifier (dbid) of the table. This will be the child table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     * @param  \Rossity\PhpQuickbase\Model\InlineObject6 $generated (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createRelationshipAsyncWithHttpInfo($tableId, $qBRealmHostname, $authorization, $userAgent = null, $generated = null)
    {
        $returnType = 'map[string,object]';
        $request = $this->createRelationshipRequest($tableId, $qBRealmHostname, $authorization, $userAgent, $generated);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createRelationship'
     *
     * @param  string $tableId The unique identifier (dbid) of the table. This will be the child table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     * @param  \Rossity\PhpQuickbase\Model\InlineObject6 $generated (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createRelationshipRequest($tableId, $qBRealmHostname, $authorization, $userAgent = null, $generated = null)
    {
        // verify the required parameter 'tableId' is set
        if ($tableId === null || (is_array($tableId) && count($tableId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tableId when calling createRelationship'
            );
        }
        // verify the required parameter 'qBRealmHostname' is set
        if ($qBRealmHostname === null || (is_array($qBRealmHostname) && count($qBRealmHostname) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $qBRealmHostname when calling createRelationship'
            );
        }
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling createRelationship'
            );
        }

        $resourcePath = '/tables/{tableId}/relationship';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($qBRealmHostname !== null) {
            $headerParams['QB-Realm-Hostname'] = ObjectSerializer::toHeaderValue($qBRealmHostname);
        }
        // header params
        if ($userAgent !== null) {
            $headerParams['User-Agent'] = ObjectSerializer::toHeaderValue($userAgent);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($tableId !== null) {
            $resourcePath = str_replace(
                '{' . 'tableId' . '}',
                ObjectSerializer::toPathValue($tableId),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($generated)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($generated));
            } else {
                $httpBody = $generated;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createTable
     *
     * Create a table
     *
     * @param  string $appId The unique identifier of an app (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     * @param  \Rossity\PhpQuickbase\Model\InlineObject4 $generated generated (optional)
     *
     * @throws \Rossity\PhpQuickbase\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return map[string,object]
     */
    public function createTable($appId, $qBRealmHostname, $authorization, $userAgent = null, $generated = null)
    {
        list($response) = $this->createTableWithHttpInfo($appId, $qBRealmHostname, $authorization, $userAgent, $generated);
        return $response;
    }

    /**
     * Operation createTableWithHttpInfo
     *
     * Create a table
     *
     * @param  string $appId The unique identifier of an app (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     * @param  \Rossity\PhpQuickbase\Model\InlineObject4 $generated (optional)
     *
     * @throws \Rossity\PhpQuickbase\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of map[string,object], HTTP status code, HTTP response headers (array of strings)
     */
    public function createTableWithHttpInfo($appId, $qBRealmHostname, $authorization, $userAgent = null, $generated = null)
    {
        $request = $this->createTableRequest($appId, $qBRealmHostname, $authorization, $userAgent, $generated);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('map[string,object]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'map[string,object]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'map[string,object]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,object]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createTableAsync
     *
     * Create a table
     *
     * @param  string $appId The unique identifier of an app (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     * @param  \Rossity\PhpQuickbase\Model\InlineObject4 $generated (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTableAsync($appId, $qBRealmHostname, $authorization, $userAgent = null, $generated = null)
    {
        return $this->createTableAsyncWithHttpInfo($appId, $qBRealmHostname, $authorization, $userAgent, $generated)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createTableAsyncWithHttpInfo
     *
     * Create a table
     *
     * @param  string $appId The unique identifier of an app (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     * @param  \Rossity\PhpQuickbase\Model\InlineObject4 $generated (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTableAsyncWithHttpInfo($appId, $qBRealmHostname, $authorization, $userAgent = null, $generated = null)
    {
        $returnType = 'map[string,object]';
        $request = $this->createTableRequest($appId, $qBRealmHostname, $authorization, $userAgent, $generated);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createTable'
     *
     * @param  string $appId The unique identifier of an app (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     * @param  \Rossity\PhpQuickbase\Model\InlineObject4 $generated (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createTableRequest($appId, $qBRealmHostname, $authorization, $userAgent = null, $generated = null)
    {
        // verify the required parameter 'appId' is set
        if ($appId === null || (is_array($appId) && count($appId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $appId when calling createTable'
            );
        }
        // verify the required parameter 'qBRealmHostname' is set
        if ($qBRealmHostname === null || (is_array($qBRealmHostname) && count($qBRealmHostname) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $qBRealmHostname when calling createTable'
            );
        }
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling createTable'
            );
        }

        $resourcePath = '/tables';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($appId)) {
            $appId = ObjectSerializer::serializeCollection($appId, '', true);
        }
        if ($appId !== null) {
            $queryParams['appId'] = $appId;
        }

        // header params
        if ($qBRealmHostname !== null) {
            $headerParams['QB-Realm-Hostname'] = ObjectSerializer::toHeaderValue($qBRealmHostname);
        }
        // header params
        if ($userAgent !== null) {
            $headerParams['User-Agent'] = ObjectSerializer::toHeaderValue($userAgent);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }



        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($generated)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($generated));
            } else {
                $httpBody = $generated;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteRelationship
     *
     * Delete a relationship
     *
     * @param  string $tableId The unique identifier (dbid) of the table. This will be the child table. (required)
     * @param  float $relationshipId The relationship id. This is the field id of the reference field on the child table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \Rossity\PhpQuickbase\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return map[string,object]
     */
    public function deleteRelationship($tableId, $relationshipId, $qBRealmHostname, $authorization, $userAgent = null)
    {
        list($response) = $this->deleteRelationshipWithHttpInfo($tableId, $relationshipId, $qBRealmHostname, $authorization, $userAgent);
        return $response;
    }

    /**
     * Operation deleteRelationshipWithHttpInfo
     *
     * Delete a relationship
     *
     * @param  string $tableId The unique identifier (dbid) of the table. This will be the child table. (required)
     * @param  float $relationshipId The relationship id. This is the field id of the reference field on the child table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \Rossity\PhpQuickbase\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of map[string,object], HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteRelationshipWithHttpInfo($tableId, $relationshipId, $qBRealmHostname, $authorization, $userAgent = null)
    {
        $request = $this->deleteRelationshipRequest($tableId, $relationshipId, $qBRealmHostname, $authorization, $userAgent);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('map[string,object]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'map[string,object]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'map[string,object]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,object]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteRelationshipAsync
     *
     * Delete a relationship
     *
     * @param  string $tableId The unique identifier (dbid) of the table. This will be the child table. (required)
     * @param  float $relationshipId The relationship id. This is the field id of the reference field on the child table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRelationshipAsync($tableId, $relationshipId, $qBRealmHostname, $authorization, $userAgent = null)
    {
        return $this->deleteRelationshipAsyncWithHttpInfo($tableId, $relationshipId, $qBRealmHostname, $authorization, $userAgent)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteRelationshipAsyncWithHttpInfo
     *
     * Delete a relationship
     *
     * @param  string $tableId The unique identifier (dbid) of the table. This will be the child table. (required)
     * @param  float $relationshipId The relationship id. This is the field id of the reference field on the child table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteRelationshipAsyncWithHttpInfo($tableId, $relationshipId, $qBRealmHostname, $authorization, $userAgent = null)
    {
        $returnType = 'map[string,object]';
        $request = $this->deleteRelationshipRequest($tableId, $relationshipId, $qBRealmHostname, $authorization, $userAgent);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteRelationship'
     *
     * @param  string $tableId The unique identifier (dbid) of the table. This will be the child table. (required)
     * @param  float $relationshipId The relationship id. This is the field id of the reference field on the child table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteRelationshipRequest($tableId, $relationshipId, $qBRealmHostname, $authorization, $userAgent = null)
    {
        // verify the required parameter 'tableId' is set
        if ($tableId === null || (is_array($tableId) && count($tableId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tableId when calling deleteRelationship'
            );
        }
        // verify the required parameter 'relationshipId' is set
        if ($relationshipId === null || (is_array($relationshipId) && count($relationshipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $relationshipId when calling deleteRelationship'
            );
        }
        // verify the required parameter 'qBRealmHostname' is set
        if ($qBRealmHostname === null || (is_array($qBRealmHostname) && count($qBRealmHostname) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $qBRealmHostname when calling deleteRelationship'
            );
        }
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling deleteRelationship'
            );
        }

        $resourcePath = '/tables/{tableId}/relationship/{relationshipId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($qBRealmHostname !== null) {
            $headerParams['QB-Realm-Hostname'] = ObjectSerializer::toHeaderValue($qBRealmHostname);
        }
        // header params
        if ($userAgent !== null) {
            $headerParams['User-Agent'] = ObjectSerializer::toHeaderValue($userAgent);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($tableId !== null) {
            $resourcePath = str_replace(
                '{' . 'tableId' . '}',
                ObjectSerializer::toPathValue($tableId),
                $resourcePath
            );
        }
        // path params
        if ($relationshipId !== null) {
            $resourcePath = str_replace(
                '{' . 'relationshipId' . '}',
                ObjectSerializer::toPathValue($relationshipId),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteTable
     *
     * Delete a table
     *
     * @param  string $tableId The unique identifier (dbid) of the table. (required)
     * @param  string $appId The unique identifier of an app (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \Rossity\PhpQuickbase\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return map[string,object]
     */
    public function deleteTable($tableId, $appId, $qBRealmHostname, $authorization, $userAgent = null)
    {
        list($response) = $this->deleteTableWithHttpInfo($tableId, $appId, $qBRealmHostname, $authorization, $userAgent);
        return $response;
    }

    /**
     * Operation deleteTableWithHttpInfo
     *
     * Delete a table
     *
     * @param  string $tableId The unique identifier (dbid) of the table. (required)
     * @param  string $appId The unique identifier of an app (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \Rossity\PhpQuickbase\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of map[string,object], HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteTableWithHttpInfo($tableId, $appId, $qBRealmHostname, $authorization, $userAgent = null)
    {
        $request = $this->deleteTableRequest($tableId, $appId, $qBRealmHostname, $authorization, $userAgent);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('map[string,object]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'map[string,object]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'map[string,object]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,object]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteTableAsync
     *
     * Delete a table
     *
     * @param  string $tableId The unique identifier (dbid) of the table. (required)
     * @param  string $appId The unique identifier of an app (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTableAsync($tableId, $appId, $qBRealmHostname, $authorization, $userAgent = null)
    {
        return $this->deleteTableAsyncWithHttpInfo($tableId, $appId, $qBRealmHostname, $authorization, $userAgent)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteTableAsyncWithHttpInfo
     *
     * Delete a table
     *
     * @param  string $tableId The unique identifier (dbid) of the table. (required)
     * @param  string $appId The unique identifier of an app (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteTableAsyncWithHttpInfo($tableId, $appId, $qBRealmHostname, $authorization, $userAgent = null)
    {
        $returnType = 'map[string,object]';
        $request = $this->deleteTableRequest($tableId, $appId, $qBRealmHostname, $authorization, $userAgent);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteTable'
     *
     * @param  string $tableId The unique identifier (dbid) of the table. (required)
     * @param  string $appId The unique identifier of an app (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteTableRequest($tableId, $appId, $qBRealmHostname, $authorization, $userAgent = null)
    {
        // verify the required parameter 'tableId' is set
        if ($tableId === null || (is_array($tableId) && count($tableId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tableId when calling deleteTable'
            );
        }
        // verify the required parameter 'appId' is set
        if ($appId === null || (is_array($appId) && count($appId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $appId when calling deleteTable'
            );
        }
        // verify the required parameter 'qBRealmHostname' is set
        if ($qBRealmHostname === null || (is_array($qBRealmHostname) && count($qBRealmHostname) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $qBRealmHostname when calling deleteTable'
            );
        }
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling deleteTable'
            );
        }

        $resourcePath = '/tables/{tableId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($appId)) {
            $appId = ObjectSerializer::serializeCollection($appId, '', true);
        }
        if ($appId !== null) {
            $queryParams['appId'] = $appId;
        }

        // header params
        if ($qBRealmHostname !== null) {
            $headerParams['QB-Realm-Hostname'] = ObjectSerializer::toHeaderValue($qBRealmHostname);
        }
        // header params
        if ($userAgent !== null) {
            $headerParams['User-Agent'] = ObjectSerializer::toHeaderValue($userAgent);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($tableId !== null) {
            $resourcePath = str_replace(
                '{' . 'tableId' . '}',
                ObjectSerializer::toPathValue($tableId),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAppTables
     *
     * Get tables for an app
     *
     * @param  string $appId The unique identifier of an app (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \Rossity\PhpQuickbase\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Rossity\PhpQuickbase\Model\InlineResponse2001[]
     */
    public function getAppTables($appId, $qBRealmHostname, $authorization, $userAgent = null)
    {
        list($response) = $this->getAppTablesWithHttpInfo($appId, $qBRealmHostname, $authorization, $userAgent);
        return $response;
    }

    /**
     * Operation getAppTablesWithHttpInfo
     *
     * Get tables for an app
     *
     * @param  string $appId The unique identifier of an app (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \Rossity\PhpQuickbase\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Rossity\PhpQuickbase\Model\InlineResponse2001[], HTTP status code, HTTP response headers (array of strings)
     */
    public function getAppTablesWithHttpInfo($appId, $qBRealmHostname, $authorization, $userAgent = null)
    {
        $request = $this->getAppTablesRequest($appId, $qBRealmHostname, $authorization, $userAgent);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('\Rossity\PhpQuickbase\Model\InlineResponse2001[]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Rossity\PhpQuickbase\Model\InlineResponse2001[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Rossity\PhpQuickbase\Model\InlineResponse2001[]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Rossity\PhpQuickbase\Model\InlineResponse2001[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAppTablesAsync
     *
     * Get tables for an app
     *
     * @param  string $appId The unique identifier of an app (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAppTablesAsync($appId, $qBRealmHostname, $authorization, $userAgent = null)
    {
        return $this->getAppTablesAsyncWithHttpInfo($appId, $qBRealmHostname, $authorization, $userAgent)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAppTablesAsyncWithHttpInfo
     *
     * Get tables for an app
     *
     * @param  string $appId The unique identifier of an app (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAppTablesAsyncWithHttpInfo($appId, $qBRealmHostname, $authorization, $userAgent = null)
    {
        $returnType = '\Rossity\PhpQuickbase\Model\InlineResponse2001[]';
        $request = $this->getAppTablesRequest($appId, $qBRealmHostname, $authorization, $userAgent);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAppTables'
     *
     * @param  string $appId The unique identifier of an app (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAppTablesRequest($appId, $qBRealmHostname, $authorization, $userAgent = null)
    {
        // verify the required parameter 'appId' is set
        if ($appId === null || (is_array($appId) && count($appId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $appId when calling getAppTables'
            );
        }
        // verify the required parameter 'qBRealmHostname' is set
        if ($qBRealmHostname === null || (is_array($qBRealmHostname) && count($qBRealmHostname) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $qBRealmHostname when calling getAppTables'
            );
        }
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling getAppTables'
            );
        }

        $resourcePath = '/tables';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($appId)) {
            $appId = ObjectSerializer::serializeCollection($appId, '', true);
        }
        if ($appId !== null) {
            $queryParams['appId'] = $appId;
        }

        // header params
        if ($qBRealmHostname !== null) {
            $headerParams['QB-Realm-Hostname'] = ObjectSerializer::toHeaderValue($qBRealmHostname);
        }
        // header params
        if ($userAgent !== null) {
            $headerParams['User-Agent'] = ObjectSerializer::toHeaderValue($userAgent);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }



        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getRelationships
     *
     * Get all relationships
     *
     * @param  string $tableId The unique identifier (dbid) of the table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \Rossity\PhpQuickbase\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return map[string,object]
     */
    public function getRelationships($tableId, $qBRealmHostname, $authorization, $userAgent = null)
    {
        list($response) = $this->getRelationshipsWithHttpInfo($tableId, $qBRealmHostname, $authorization, $userAgent);
        return $response;
    }

    /**
     * Operation getRelationshipsWithHttpInfo
     *
     * Get all relationships
     *
     * @param  string $tableId The unique identifier (dbid) of the table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \Rossity\PhpQuickbase\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of map[string,object], HTTP status code, HTTP response headers (array of strings)
     */
    public function getRelationshipsWithHttpInfo($tableId, $qBRealmHostname, $authorization, $userAgent = null)
    {
        $request = $this->getRelationshipsRequest($tableId, $qBRealmHostname, $authorization, $userAgent);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('map[string,object]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'map[string,object]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'map[string,object]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,object]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getRelationshipsAsync
     *
     * Get all relationships
     *
     * @param  string $tableId The unique identifier (dbid) of the table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRelationshipsAsync($tableId, $qBRealmHostname, $authorization, $userAgent = null)
    {
        return $this->getRelationshipsAsyncWithHttpInfo($tableId, $qBRealmHostname, $authorization, $userAgent)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getRelationshipsAsyncWithHttpInfo
     *
     * Get all relationships
     *
     * @param  string $tableId The unique identifier (dbid) of the table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getRelationshipsAsyncWithHttpInfo($tableId, $qBRealmHostname, $authorization, $userAgent = null)
    {
        $returnType = 'map[string,object]';
        $request = $this->getRelationshipsRequest($tableId, $qBRealmHostname, $authorization, $userAgent);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getRelationships'
     *
     * @param  string $tableId The unique identifier (dbid) of the table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getRelationshipsRequest($tableId, $qBRealmHostname, $authorization, $userAgent = null)
    {
        // verify the required parameter 'tableId' is set
        if ($tableId === null || (is_array($tableId) && count($tableId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tableId when calling getRelationships'
            );
        }
        // verify the required parameter 'qBRealmHostname' is set
        if ($qBRealmHostname === null || (is_array($qBRealmHostname) && count($qBRealmHostname) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $qBRealmHostname when calling getRelationships'
            );
        }
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling getRelationships'
            );
        }

        $resourcePath = '/tables/{tableId}/relationships';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($qBRealmHostname !== null) {
            $headerParams['QB-Realm-Hostname'] = ObjectSerializer::toHeaderValue($qBRealmHostname);
        }
        // header params
        if ($userAgent !== null) {
            $headerParams['User-Agent'] = ObjectSerializer::toHeaderValue($userAgent);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($tableId !== null) {
            $resourcePath = str_replace(
                '{' . 'tableId' . '}',
                ObjectSerializer::toPathValue($tableId),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getTable
     *
     * Get a table
     *
     * @param  string $tableId The unique identifier (dbid) of the table. (required)
     * @param  string $appId The unique identifier of an app (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \Rossity\PhpQuickbase\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return map[string,object]
     */
    public function getTable($tableId, $appId, $qBRealmHostname, $authorization, $userAgent = null)
    {
        list($response) = $this->getTableWithHttpInfo($tableId, $appId, $qBRealmHostname, $authorization, $userAgent);
        return $response;
    }

    /**
     * Operation getTableWithHttpInfo
     *
     * Get a table
     *
     * @param  string $tableId The unique identifier (dbid) of the table. (required)
     * @param  string $appId The unique identifier of an app (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \Rossity\PhpQuickbase\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of map[string,object], HTTP status code, HTTP response headers (array of strings)
     */
    public function getTableWithHttpInfo($tableId, $appId, $qBRealmHostname, $authorization, $userAgent = null)
    {
        $request = $this->getTableRequest($tableId, $appId, $qBRealmHostname, $authorization, $userAgent);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('map[string,object]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'map[string,object]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'map[string,object]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,object]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getTableAsync
     *
     * Get a table
     *
     * @param  string $tableId The unique identifier (dbid) of the table. (required)
     * @param  string $appId The unique identifier of an app (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTableAsync($tableId, $appId, $qBRealmHostname, $authorization, $userAgent = null)
    {
        return $this->getTableAsyncWithHttpInfo($tableId, $appId, $qBRealmHostname, $authorization, $userAgent)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getTableAsyncWithHttpInfo
     *
     * Get a table
     *
     * @param  string $tableId The unique identifier (dbid) of the table. (required)
     * @param  string $appId The unique identifier of an app (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getTableAsyncWithHttpInfo($tableId, $appId, $qBRealmHostname, $authorization, $userAgent = null)
    {
        $returnType = 'map[string,object]';
        $request = $this->getTableRequest($tableId, $appId, $qBRealmHostname, $authorization, $userAgent);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getTable'
     *
     * @param  string $tableId The unique identifier (dbid) of the table. (required)
     * @param  string $appId The unique identifier of an app (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getTableRequest($tableId, $appId, $qBRealmHostname, $authorization, $userAgent = null)
    {
        // verify the required parameter 'tableId' is set
        if ($tableId === null || (is_array($tableId) && count($tableId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tableId when calling getTable'
            );
        }
        // verify the required parameter 'appId' is set
        if ($appId === null || (is_array($appId) && count($appId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $appId when calling getTable'
            );
        }
        // verify the required parameter 'qBRealmHostname' is set
        if ($qBRealmHostname === null || (is_array($qBRealmHostname) && count($qBRealmHostname) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $qBRealmHostname when calling getTable'
            );
        }
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling getTable'
            );
        }

        $resourcePath = '/tables/{tableId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($appId)) {
            $appId = ObjectSerializer::serializeCollection($appId, '', true);
        }
        if ($appId !== null) {
            $queryParams['appId'] = $appId;
        }

        // header params
        if ($qBRealmHostname !== null) {
            $headerParams['QB-Realm-Hostname'] = ObjectSerializer::toHeaderValue($qBRealmHostname);
        }
        // header params
        if ($userAgent !== null) {
            $headerParams['User-Agent'] = ObjectSerializer::toHeaderValue($userAgent);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($tableId !== null) {
            $resourcePath = str_replace(
                '{' . 'tableId' . '}',
                ObjectSerializer::toPathValue($tableId),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateRelationship
     *
     * Update a relationship
     *
     * @param  string $tableId The unique identifier (dbid) of the table. This will be the child table. (required)
     * @param  float $relationshipId The relationship id. This is the field id of the reference field on the child table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     * @param  \Rossity\PhpQuickbase\Model\InlineObject7 $generated generated (optional)
     *
     * @throws \Rossity\PhpQuickbase\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return map[string,object]
     */
    public function updateRelationship($tableId, $relationshipId, $qBRealmHostname, $authorization, $userAgent = null, $generated = null)
    {
        list($response) = $this->updateRelationshipWithHttpInfo($tableId, $relationshipId, $qBRealmHostname, $authorization, $userAgent, $generated);
        return $response;
    }

    /**
     * Operation updateRelationshipWithHttpInfo
     *
     * Update a relationship
     *
     * @param  string $tableId The unique identifier (dbid) of the table. This will be the child table. (required)
     * @param  float $relationshipId The relationship id. This is the field id of the reference field on the child table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     * @param  \Rossity\PhpQuickbase\Model\InlineObject7 $generated (optional)
     *
     * @throws \Rossity\PhpQuickbase\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of map[string,object], HTTP status code, HTTP response headers (array of strings)
     */
    public function updateRelationshipWithHttpInfo($tableId, $relationshipId, $qBRealmHostname, $authorization, $userAgent = null, $generated = null)
    {
        $request = $this->updateRelationshipRequest($tableId, $relationshipId, $qBRealmHostname, $authorization, $userAgent, $generated);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('map[string,object]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'map[string,object]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'map[string,object]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,object]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateRelationshipAsync
     *
     * Update a relationship
     *
     * @param  string $tableId The unique identifier (dbid) of the table. This will be the child table. (required)
     * @param  float $relationshipId The relationship id. This is the field id of the reference field on the child table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     * @param  \Rossity\PhpQuickbase\Model\InlineObject7 $generated (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateRelationshipAsync($tableId, $relationshipId, $qBRealmHostname, $authorization, $userAgent = null, $generated = null)
    {
        return $this->updateRelationshipAsyncWithHttpInfo($tableId, $relationshipId, $qBRealmHostname, $authorization, $userAgent, $generated)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateRelationshipAsyncWithHttpInfo
     *
     * Update a relationship
     *
     * @param  string $tableId The unique identifier (dbid) of the table. This will be the child table. (required)
     * @param  float $relationshipId The relationship id. This is the field id of the reference field on the child table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     * @param  \Rossity\PhpQuickbase\Model\InlineObject7 $generated (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateRelationshipAsyncWithHttpInfo($tableId, $relationshipId, $qBRealmHostname, $authorization, $userAgent = null, $generated = null)
    {
        $returnType = 'map[string,object]';
        $request = $this->updateRelationshipRequest($tableId, $relationshipId, $qBRealmHostname, $authorization, $userAgent, $generated);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateRelationship'
     *
     * @param  string $tableId The unique identifier (dbid) of the table. This will be the child table. (required)
     * @param  float $relationshipId The relationship id. This is the field id of the reference field on the child table. (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     * @param  \Rossity\PhpQuickbase\Model\InlineObject7 $generated (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateRelationshipRequest($tableId, $relationshipId, $qBRealmHostname, $authorization, $userAgent = null, $generated = null)
    {
        // verify the required parameter 'tableId' is set
        if ($tableId === null || (is_array($tableId) && count($tableId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tableId when calling updateRelationship'
            );
        }
        // verify the required parameter 'relationshipId' is set
        if ($relationshipId === null || (is_array($relationshipId) && count($relationshipId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $relationshipId when calling updateRelationship'
            );
        }
        // verify the required parameter 'qBRealmHostname' is set
        if ($qBRealmHostname === null || (is_array($qBRealmHostname) && count($qBRealmHostname) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $qBRealmHostname when calling updateRelationship'
            );
        }
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling updateRelationship'
            );
        }

        $resourcePath = '/tables/{tableId}/relationship/{relationshipId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($qBRealmHostname !== null) {
            $headerParams['QB-Realm-Hostname'] = ObjectSerializer::toHeaderValue($qBRealmHostname);
        }
        // header params
        if ($userAgent !== null) {
            $headerParams['User-Agent'] = ObjectSerializer::toHeaderValue($userAgent);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($tableId !== null) {
            $resourcePath = str_replace(
                '{' . 'tableId' . '}',
                ObjectSerializer::toPathValue($tableId),
                $resourcePath
            );
        }
        // path params
        if ($relationshipId !== null) {
            $resourcePath = str_replace(
                '{' . 'relationshipId' . '}',
                ObjectSerializer::toPathValue($relationshipId),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($generated)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($generated));
            } else {
                $httpBody = $generated;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateTable
     *
     * Update a table
     *
     * @param  string $tableId The unique identifier (dbid) of the table. (required)
     * @param  string $appId The unique identifier of an app (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     * @param  \Rossity\PhpQuickbase\Model\InlineObject5 $generated generated (optional)
     *
     * @throws \Rossity\PhpQuickbase\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return map[string,object]
     */
    public function updateTable($tableId, $appId, $qBRealmHostname, $authorization, $userAgent = null, $generated = null)
    {
        list($response) = $this->updateTableWithHttpInfo($tableId, $appId, $qBRealmHostname, $authorization, $userAgent, $generated);
        return $response;
    }

    /**
     * Operation updateTableWithHttpInfo
     *
     * Update a table
     *
     * @param  string $tableId The unique identifier (dbid) of the table. (required)
     * @param  string $appId The unique identifier of an app (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     * @param  \Rossity\PhpQuickbase\Model\InlineObject5 $generated (optional)
     *
     * @throws \Rossity\PhpQuickbase\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of map[string,object], HTTP status code, HTTP response headers (array of strings)
     */
    public function updateTableWithHttpInfo($tableId, $appId, $qBRealmHostname, $authorization, $userAgent = null, $generated = null)
    {
        $request = $this->updateTableRequest($tableId, $appId, $qBRealmHostname, $authorization, $userAgent, $generated);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            switch($statusCode) {
                case 200:
                    if ('map[string,object]' === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'map[string,object]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = 'map[string,object]';
            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = (string) $responseBody;
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,object]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateTableAsync
     *
     * Update a table
     *
     * @param  string $tableId The unique identifier (dbid) of the table. (required)
     * @param  string $appId The unique identifier of an app (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     * @param  \Rossity\PhpQuickbase\Model\InlineObject5 $generated (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTableAsync($tableId, $appId, $qBRealmHostname, $authorization, $userAgent = null, $generated = null)
    {
        return $this->updateTableAsyncWithHttpInfo($tableId, $appId, $qBRealmHostname, $authorization, $userAgent, $generated)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateTableAsyncWithHttpInfo
     *
     * Update a table
     *
     * @param  string $tableId The unique identifier (dbid) of the table. (required)
     * @param  string $appId The unique identifier of an app (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     * @param  \Rossity\PhpQuickbase\Model\InlineObject5 $generated (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateTableAsyncWithHttpInfo($tableId, $appId, $qBRealmHostname, $authorization, $userAgent = null, $generated = null)
    {
        $returnType = 'map[string,object]';
        $request = $this->updateTableRequest($tableId, $appId, $qBRealmHostname, $authorization, $userAgent, $generated);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = (string) $responseBody;
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateTable'
     *
     * @param  string $tableId The unique identifier (dbid) of the table. (required)
     * @param  string $appId The unique identifier of an app (required)
     * @param  string $qBRealmHostname Your Quick Base domain, for example demo.quickbase.com (required)
     * @param  string $authorization The Quick Base authentication scheme you are using to authenticate the request, as described on the [authorization page](../auth). (required)
     * @param  string $userAgent This is entered by the person or utility invoking the API. You might custom create this or use the default one of your toolkit. Being descriptive here may offer more identification and troubleshooting capabilities. (optional)
     * @param  \Rossity\PhpQuickbase\Model\InlineObject5 $generated (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function updateTableRequest($tableId, $appId, $qBRealmHostname, $authorization, $userAgent = null, $generated = null)
    {
        // verify the required parameter 'tableId' is set
        if ($tableId === null || (is_array($tableId) && count($tableId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tableId when calling updateTable'
            );
        }
        // verify the required parameter 'appId' is set
        if ($appId === null || (is_array($appId) && count($appId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $appId when calling updateTable'
            );
        }
        // verify the required parameter 'qBRealmHostname' is set
        if ($qBRealmHostname === null || (is_array($qBRealmHostname) && count($qBRealmHostname) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $qBRealmHostname when calling updateTable'
            );
        }
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling updateTable'
            );
        }

        $resourcePath = '/tables/{tableId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if (is_array($appId)) {
            $appId = ObjectSerializer::serializeCollection($appId, '', true);
        }
        if ($appId !== null) {
            $queryParams['appId'] = $appId;
        }

        // header params
        if ($qBRealmHostname !== null) {
            $headerParams['QB-Realm-Hostname'] = ObjectSerializer::toHeaderValue($qBRealmHostname);
        }
        // header params
        if ($userAgent !== null) {
            $headerParams['User-Agent'] = ObjectSerializer::toHeaderValue($userAgent);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($tableId !== null) {
            $resourcePath = str_replace(
                '{' . 'tableId' . '}',
                ObjectSerializer::toPathValue($tableId),
                $resourcePath
            );
        }


        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                []
            );
        }

        // for model (json/xml)
        if (isset($generated)) {
            if ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($generated));
            } else {
                $httpBody = $generated;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
